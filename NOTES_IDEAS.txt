ENGINE EDITOR NOTES:
- In 3D scene editor, press 'mouse right' for WASD movement
- Press shift and scroll mouse wheel to modify movement speed
- Press shift to 'run'

https://www.youtube.com/watch?v=2mpklUE7BfA&ab_channel=DanielPHFox

- The Voxel Extension does not have complicated generation logic, but it allows for easy insertion of such logic
- For example, cave density and height capping: The extension just does everything randomly, but users can control this.
- The base 2d noise map does not provide erosion algorithms, so I will need to create this. 
- The extension allows for insertion for custom noise maps.
- The extension allows for starting seeds, allowing for deterministic generation.

CURRENT PLAN:
- YOU DO NOT NEED FANCY EROSION ALGORITHMS!!! 
- MORROWIND'S BASE WAS DONE WITH A PROC GEN TERRAIN, BUT NO EROSION
- I need to create a biome layer (2d noise map)
- I need to create a erosion layer
- I need 1 layer for each random element: rivers, trees, lakes, towns, cliffs, e.t.c

- Create the base terrain with standard heightmap meshes, and then generate voxels only for overhanging terrain and caves
- Because the terrain is static, and caves/overhang should be mildly sparse, it should still be faster than pure voxels
- Hard part would be to figure out how to stitch the 2 meshes

NOISE RELATED:
- The noise map can be generated in script, but would be extremely slow. Instead, generate using compute shaders
- Compute shaders can be configured so that each vertex's heightmap are computed in parallel. Loops are discouraged.

- Downloading GPU processed data to CPU is slow, but it is fast to send CPU data to GPU. 
- Create a double or triple buffer where CPU sends data to GPU in succession, and processes it right after.

- First step is to create the compute shader code and attempt base code before double buffers and such.
- initialize the shader stuff at clipmap _ready() - will only run once on clipmap init

- Okay, so the biggest reason as to why the terrain feels low res is because the image is low resolution as well. 
- Even if we crammed the heightmap into a smaller mesh, it would also smoosh the general design, so that would be pointless
- The gap between the vertices will be larger than I want, unless we use some sort of smoothening algorithm
- speaking of which, remember to implement basic erosion

- In theory, if vertices were shared between triangles, smooth shading would be easy. But it also removes the option for low-poly design


- Write the compute shader stuff, make the heightmap calculate for much higher than 512 (1024 is next) 
- The godot compute shader example generates the noise on cpu, and just applies it to the vertices on the gpu
- Fast, accurate, and would allow combining noise algorithms fairly easily

- When the layout says 8 specifically, it does not mean that it will only take 8x8 input nessecarily 
- It just means thats the amount of the input that will be worked on at a time

- The heightmap should only be generated once, or in large chunks

https://www.youtube.com/watch?v=jDM0m4WuBAg&t=247s&ab_channel=DitzyNinja%27sGodojo
https://github.com/TheGodojo/Massive-Terrain-LOD-And-Stitching-COMPLETE
https://docs.godotengine.org/en/stable/tutorials/shaders/compute_shaders.html
https://github.com/godotengine/godot-demo-projects/blob/master/misc/compute_shader_heightmap/compute_shader.glsl
https://github.com/KdotJPG/OpenSimplex2/blob/master/glsl/OpenSimplex2.glsl


TRACE OUTLINE:
- The game starts
- clipmap spawns, does its thing and spawns a clipmap_partition for every defined square in the grid
- in the ready function of the clipmap, it intializes the compute shader
- it creates a base image for the heightmap, where the seed, noise function, gradient, e.t.c is applied
- this base image is passed off to the compute shader
- the compute shader has specific values that define how many values it will be work with at a time
- the compute shader should only be used for simple calculations that need to be done repeatedly, but the next results do not rely on the previous one

- results are downloaded to the cpu (we need to do that for collision, otherwise I would've just passed it directly to the vertex shader)
 
